<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Matrix for Scientific computation"><title>peroxide::structure::matrix - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-46132b98.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="peroxide" data-themes="" data-resource-suffix="" data-rustdoc-version="1.85.1 (4eb161250 2025-03-15)" data-channel="1.85.1" data-search-js="search-75f5ac3e.js" data-settings-js="settings-0f613d39.js" ><script src="../../../static.files/storage-59e33391.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../../static.files/main-5f194d8c.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-893ab5e7.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-6580c154.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-044be391.svg"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.css" integrity="sha384-9eLZqc9ds8eNjO3TmqPeYcDj8n+Qfa4nuSiGYa6DjLNcv9BtN69ZIulL9+8CqC9Y" crossorigin="anonymous">
<script src="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/katex.min.js"                  integrity="sha384-K3vbOmF2BtaVai+Qk37uypf7VrgBubhQreNQe9aGsz9lB63dIFiQVlJbr92dw2Lx" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/katex@0.10.0/dist/contrib/auto-render.min.js"    integrity="sha384-kmZOZB5ObwgQnS/DuDg6TScgOiWWBiVt0plIRkZCmE6rDZGrEOQeHM5PcHi+nyqe" crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
            delimiters: [
                {left: "$$", right: "$$", display: true},
                {left: "\\(", right: "\\)", display: false},
                {left: "$", right: "$", display: false},
                {left: "\\[", right: "\\]", display: true}
            ]
        });
    });
</script>

</head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../../peroxide/index.html">peroxide</a><span class="version">0.39.4</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Module matrix</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#declare-matrix" title="Declare matrix">Declare matrix</a><ul><li><a href="#rs-way" title="R’s way">R’s way</a></li><li><a href="#matlabs-way" title="MATLAB’s way">MATLAB’s way</a></li><li><a href="#pythons-way" title="Python’s way">Python’s way</a></li><li><a href="#other-macro" title="Other macro">Other macro</a></li></ul></li><li><a href="#basic-method-for-matrix" title="Basic Method for Matrix">Basic Method for Matrix</a></li><li><a href="#read--write" title="Read &#38; Write">Read &amp; Write</a><ul><li><a href="#csv-not-recommended" title="CSV (Not recommended)">CSV (Not recommended)</a></li><li><a href="#convert-to-dataframe-recommended" title="Convert to DataFrame (Recommended)">Convert to DataFrame (Recommended)</a></li></ul></li><li><a href="#concatenation" title="Concatenation">Concatenation</a></li><li><a href="#matrix-operations" title="Matrix operations">Matrix operations</a></li><li><a href="#extract--modify-components" title="Extract &#38; modify components">Extract &amp; modify components</a></li><li><a href="#conversion-to-vecf64" title="Conversion to `Vec&#60;f64&#62;`">Conversion to <code>Vec&lt;f64&gt;</code></a></li><li><a href="#useful-constructor" title="Useful constructor">Useful constructor</a></li><li><a href="#linear-algebra" title="Linear Algebra">Linear Algebra</a><ul><li><a href="#transpose" title="Transpose">Transpose</a></li><li><a href="#lu-decomposition" title="LU Decomposition">LU Decomposition</a></li><li><a href="#determinant" title="Determinant">Determinant</a></li><li><a href="#inverse-matrix" title="Inverse matrix">Inverse matrix</a></li><li><a href="#tips-for-lu-det-inverse" title="Tips for LU, Det, Inverse">Tips for LU, Det, Inverse</a></li><li><a href="#qr-decomposition-o3-feature-only" title="QR Decomposition (`O3` feature only)">QR Decomposition (<code>O3</code> feature only)</a></li><li><a href="#singular-value-decomposition-o3-feature-only" title="Singular Value Decomposition (`O3` feature only)">Singular Value Decomposition (<code>O3</code> feature only)</a></li><li><a href="#cholesky-decomposition" title="Cholesky Decomposition">Cholesky Decomposition</a></li><li><a href="#moore-penrose-pseudo-inverse" title="Moore-Penrose Pseudo Inverse">Moore-Penrose Pseudo Inverse</a></li></ul></li></ul><h3><a href="#reexports">Module Items</a></h3><ul class="block"><li><a href="#reexports" title="Re-exports">Re-exports</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#functions" title="Functions">Functions</a></li><li><a href="#types" title="Type Aliases">Type Aliases</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="../index.html">In peroxide::<wbr>structure</a></h2></div></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><span class="rustdoc-breadcrumbs"><a href="../../index.html">peroxide</a>::<wbr><a href="../index.html">structure</a></span><h1>Module <span>matrix</span><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/peroxide/structure/matrix.rs.html#1-4822">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Matrix for Scientific computation</p>
<h3 id="declare-matrix"><a class="doc-anchor" href="#declare-matrix">§</a>Declare matrix</h3>
<ul>
<li>You can declare matrix by various ways.
<ul>
<li>R’s way - Default</li>
<li>MATLAB’s way</li>
<li>Python’s way</li>
<li>Other macro</li>
</ul>
</li>
</ul>
<h4 id="rs-way"><a class="doc-anchor" href="#rs-way">§</a>R’s way</h4>
<ul>
<li>
<p>Description: Same as R - <code>matrix(Vec&lt;f64&gt;, Row, Col, Shape)</code></p>
</li>
<li>
<p>Type: <code>matrix(Vec&lt;T&gt;, usize, usize, Shape) where T: std::convert::Into&lt;f64&gt; + Copy</code></p>
<ul>
<li><code>Shape</code>: <code>Enum</code> for matrix shape - <code>Row</code> &amp; <code>Col</code></li>
</ul>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[macro_use]
</span><span class="kw">extern crate </span>peroxide;
<span class="kw">use </span>peroxide::fuga::<span class="kw-2">*</span>;

<span class="kw">fn </span>main() {
    <span class="kw">let </span>a = matrix(<span class="macro">c!</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>), <span class="number">2</span>, <span class="number">2</span>, Row);
    a.print();
    <span class="comment">//       c[0] c[1]
    // r[0]     1    2
    // r[1]     3    4

    </span><span class="kw">let </span>b = matrix(<span class="macro">c!</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>), <span class="number">2</span>, <span class="number">2</span>, Col);
    b.print();
    <span class="comment">//       c[0] c[1]
    // r[0]     1    3
    // r[1]     2    4
</span>}</code></pre></div>
</li>
</ul>
<h4 id="matlabs-way"><a class="doc-anchor" href="#matlabs-way">§</a>MATLAB’s way</h4>
<ul>
<li>
<p>Description: Similar to MATLAB (But should use <code>&amp;str</code>)</p>
</li>
<li>
<p>Type: <code>ml_matrix(&amp;str)</code></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>peroxide::fuga::<span class="kw-2">*</span>;

<span class="kw">fn </span>main() {
    <span class="kw">let </span>a = ml_matrix(<span class="string">"1 2; 3 4"</span>);
    a.print();
    <span class="comment">//       c[0] c[1]
    // r[0]     1    2
    // r[1]     3    4
</span>}</code></pre></div>
</li>
</ul>
<h4 id="pythons-way"><a class="doc-anchor" href="#pythons-way">§</a>Python’s way</h4>
<ul>
<li>
<p>Description: Declare matrix as vector of vectors.</p>
</li>
<li>
<p>Type: <code>py_matrix(Vec&lt;Vec&lt;T&gt;&gt;) where T: std::convert::Into&lt;f64&gt; + Copy</code></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>peroxide::fuga::<span class="kw-2">*</span>;

<span class="kw">fn </span>main() {
    <span class="kw">let </span>a = py_matrix(<span class="macro">vec!</span>[<span class="macro">vec!</span>[<span class="number">1</span>, <span class="number">2</span>], <span class="macro">vec!</span>[<span class="number">3</span>, <span class="number">4</span>]]);
    a.print();
    <span class="comment">//       c[0] c[1]
    // r[0]     1    2
    // r[1]     3    4
</span>}</code></pre></div>
</li>
</ul>
<h4 id="other-macro"><a class="doc-anchor" href="#other-macro">§</a>Other macro</h4>
<ul>
<li>
<p>Description: R-like macro to declare matrix</p>
</li>
<li>
<p>For <code>R</code>,</p>
<div class="example-wrap"><pre class="language-R"><code># R
a = matrix(1:4, nrow = 2, ncol = 2, byrow = T)
print(a)
#      [,1] [,2]
# [1,]    1    2
# [2,]    3    4</code></pre></div></li>
<li>
<p>For <code>Peroxide</code>,</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[macro_use]
</span><span class="kw">extern crate </span>peroxide;
<span class="kw">use </span>peroxide::fuga::<span class="kw-2">*</span>;

<span class="kw">fn </span>main() {
    <span class="kw">let </span>a = <span class="macro">matrix!</span>(<span class="number">1</span>;<span class="number">4</span>;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, Row);
    a.print();
    <span class="comment">//       c[0] c[1]
    // r[0]     1    2
    // r[1]     3    4
</span>}</code></pre></div>
</li>
</ul>
<h3 id="basic-method-for-matrix"><a class="doc-anchor" href="#basic-method-for-matrix">§</a>Basic Method for Matrix</h3>
<p>There are some useful methods for <code>Matrix</code></p>
<ul>
<li>
<p><code>row(&amp;self, index: usize) -&gt; Vec&lt;f64&gt;</code> : Extract specific row as <code>Vec&lt;f64&gt;</code></p>
</li>
<li>
<p><code>col(&amp;self, index: usize) -&gt; Vec&lt;f64&gt;</code> : Extract specific column as <code>Vec&lt;f64&gt;</code></p>
</li>
<li>
<p><code>diag(&amp;self) -&gt; Vec&lt;f64&gt;</code>: Extract diagonal components as <code>Vec&lt;f64&gt;</code></p>
</li>
<li>
<p><code>swap(&amp;self, usize, usize, Shape)</code>: Swap two rows or columns (unsafe function)</p>
</li>
<li>
<p><code>subs_col(&amp;mut self, usize, Vec&lt;f64&gt;)</code>: Substitute column with <code>Vec&lt;f64&gt;</code></p>
</li>
<li>
<p><code>subs_row(&amp;mut self, usize, Vec&lt;f64&gt;)</code>: Substitute row with <code>Vec&lt;f64&gt;</code></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[macro_use]
</span><span class="kw">extern crate </span>peroxide;
<span class="kw">use </span>peroxide::fuga::<span class="kw-2">*</span>;

<span class="kw">fn </span>main() {
    <span class="kw">let </span><span class="kw-2">mut </span>a = ml_matrix(<span class="string">"1 2; 3 4"</span>);

    a.row(<span class="number">0</span>).print(); <span class="comment">// [1, 2]
    </span>a.col(<span class="number">0</span>).print(); <span class="comment">// [1, 3]
    </span>a.diag().print(); <span class="comment">// [1, 4]
    </span><span class="kw">unsafe </span>{
        a.swap(<span class="number">0</span>, <span class="number">1</span>, Row);
    }
    a.print();
    <span class="comment">//      c[0] c[1]
    // r[0]    3    4
    // r[1]    1    2

    </span><span class="kw">let </span><span class="kw-2">mut </span>b = ml_matrix(<span class="string">"1 2;3 4"</span>);
    b.subs_col(<span class="number">0</span>, <span class="kw-2">&amp;</span><span class="macro">c!</span>(<span class="number">5</span>, <span class="number">6</span>));
    b.subs_row(<span class="number">1</span>, <span class="kw-2">&amp;</span><span class="macro">c!</span>(<span class="number">7</span>, <span class="number">8</span>));
    b.print();
    <span class="comment">//       c[0] c[1]
    // r[0]    5    2
    // r[1]    7    8
</span>}</code></pre></div>
</li>
</ul>
<h3 id="read--write"><a class="doc-anchor" href="#read--write">§</a>Read &amp; Write</h3>
<p>In peroxide, we can write matrix to <code>csv</code></p>
<h4 id="csv-not-recommended"><a class="doc-anchor" href="#csv-not-recommended">§</a>CSV (Not recommended)</h4>
<ul>
<li>
<p><code>csv</code> feature should be required</p>
</li>
<li>
<p><code>write(&amp;self, file_path: &amp;str)</code>: Write matrix to csv</p>
</li>
<li>
<p><code>write_with_header(&amp;self, file_path, header: Vec&lt;&amp;str&gt;)</code>: Write with header</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>peroxide::fuga::<span class="kw-2">*</span>;

<span class="kw">fn </span>main() {
    <span class="kw">let </span>a = ml_matrix(<span class="string">"1 2;3 4"</span>);
    a.write(<span class="string">"example_data/matrix.csv"</span>).expect(<span class="string">"Can't write file"</span>);

    <span class="kw">let </span>b = ml_matrix(<span class="string">"1 2; 3 4; 5 6"</span>);
    b.write_with_header(<span class="string">"example_data/header.csv"</span>, <span class="macro">vec!</span>[<span class="string">"odd"</span>, <span class="string">"even"</span>])
        .expect(<span class="string">"Can't write header file"</span>);
    <span class="macro">println!</span>(<span class="string">"Complete!"</span>)
}</code></pre></div>
</li>
</ul>
<p>Also, you can read matrix from csv.</p>
<ul>
<li>
<p>Type: <code>read(&amp;str, bool, char) -&gt; Result&lt;Matrix, Box&lt;Error&gt;&gt;</code></p>
</li>
<li>
<p>Description: <code>read(file_path, is_header, delimiter)</code></p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>peroxide::fuga::<span class="kw-2">*</span>;

<span class="kw">fn </span>main() {
    <span class="comment">// `csv` feature should be required
    </span><span class="kw">let </span>a = Matrix::read(<span class="string">"example_data/matrix.csv"</span>, <span class="bool-val">false</span>, <span class="string">','</span>)
        .expect(<span class="string">"Can't read matrix.csv file"</span>);
    a.print();
    <span class="comment">//       c[0] c[1]
    // r[0]     1    2
    // r[1]     3    4
</span>}</code></pre></div>
</li>
</ul>
<h4 id="convert-to-dataframe-recommended"><a class="doc-anchor" href="#convert-to-dataframe-recommended">§</a>Convert to DataFrame (Recommended)</h4>
<p>To write columns or rows, <code>DataFrame</code> and <code>nc</code> feature could be the best choice.</p>
<ul>
<li><code>nc</code> feature should be required - <code>netcdf</code> or <code>libnetcdf</code> are prerequisites.</li>
</ul>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[macro_use]
</span><span class="kw">extern crate </span>peroxide;
<span class="kw">use </span>peroxide::fuga::<span class="kw-2">*</span>;

<span class="kw">fn </span>main() {
    <span class="kw">let </span>a = matrix(<span class="macro">c!</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>), <span class="number">3</span>, <span class="number">2</span>, Col);

    <span class="comment">// Construct DataFrame
    </span><span class="kw">let </span><span class="kw-2">mut </span>df = DataFrame::new(<span class="macro">vec!</span>[]);
    df.push(<span class="string">"x"</span>, Series::new(a.col(<span class="number">0</span>)));
    df.push(<span class="string">"y"</span>, Series::new(a.col(<span class="number">1</span>)));

    <span class="comment">// Write nc file (`nc` feature should be required)
    </span>df.write_nc(<span class="string">"data.nc"</span>).expect(<span class="string">"Can't write data.nc"</span>);

    <span class="comment">// Read nc file (`nc` feature should be required)
    </span><span class="kw">let </span>dg = DataFrame::read_nc(<span class="string">"data.nc"</span>).expect(<span class="string">"Can't read data.nc"</span>);
    <span class="kw">let </span>x: Vec&lt;f64&gt; = dg[<span class="string">"x"</span>].to_vec();
    <span class="kw">let </span>y: Vec&lt;f64&gt; = dg[<span class="string">"y"</span>].to_vec();

    <span class="macro">assert_eq!</span>(a.col(<span class="number">0</span>), x);
    <span class="macro">assert_eq!</span>(a.col(<span class="number">1</span>), y);
}</code></pre></div>
<h3 id="concatenation"><a class="doc-anchor" href="#concatenation">§</a>Concatenation</h3>
<p>There are two options to concatenate matrices.</p>
<ul>
<li><code>cbind</code>: Concatenate two matrices by column direction.</li>
<li><code>rbind</code>: Concatenate two matrices by row direction.</li>
</ul>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>peroxide::fuga::<span class="kw-2">*</span>;

<span class="kw">fn </span>main() -&gt; <span class="prelude-ty">Result</span>&lt;(), Box&lt;<span class="kw">dyn </span>Error&gt;&gt; {
    <span class="kw">let </span>a = ml_matrix(<span class="string">"1 2;3 4"</span>);
    <span class="kw">let </span>b = ml_matrix(<span class="string">"5 6;7 8"</span>);

    cbind(a.clone(), b.clone())<span class="question-mark">?</span>.print();
    <span class="comment">//      c[0] c[1] c[2] c[3]
    // r[0]    1    2    5    7
    // r[1]    3    4    6    8

    </span>rbind(a, b)<span class="question-mark">?</span>.print();
    <span class="comment">//      c[0] c[1]
    // r[0]    1    2
    // r[1]    3    4
    // r[2]    5    6
    // r[3]    7    8

    </span><span class="prelude-val">Ok</span>(())
}</code></pre></div>
<h3 id="matrix-operations"><a class="doc-anchor" href="#matrix-operations">§</a>Matrix operations</h3>
<ul>
<li>
<p>In peroxide, can use basic operations between matrices. I’ll show you by examples.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[macro_use]
</span><span class="kw">extern crate </span>peroxide;
<span class="kw">use </span>peroxide::fuga::<span class="kw-2">*</span>;

<span class="kw">fn </span>main() {
    <span class="kw">let </span>a = <span class="macro">matrix!</span>(<span class="number">1</span>;<span class="number">4</span>;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, Row);
    (a.clone() + <span class="number">1</span>).print(); <span class="comment">// -, *, / are also available
    //      c[0] c[1]
    // r[0]    2    3
    // r[1]    4    5

    </span><span class="kw">let </span>b = <span class="macro">matrix!</span>(<span class="number">5</span>;<span class="number">8</span>;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, Row);
    (a.clone() + b.clone()).print(); <span class="comment">// - is also available
    //      c[0] c[1]
    // r[0]    6    8
    // r[1]   10   12

    </span>(a.clone() * b.clone()).print(); <span class="comment">// Matrix multiplication
    //      c[0] c[1]
    // r[0]   19   22
    // r[1]   43   50
</span>}</code></pre></div>
</li>
<li>
<p><code>clone</code> is too annoying - We can use reference operations!</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>peroxide::fuga::<span class="kw-2">*</span>;

<span class="kw">fn </span>main() {
    <span class="kw">let </span>a = ml_matrix(<span class="string">"1 2;3 4"</span>);
    <span class="kw">let </span>b = ml_matrix(<span class="string">"5 6;7 8"</span>);

    (<span class="kw-2">&amp;</span>a + <span class="number">1</span>).print();
    (<span class="kw-2">&amp;</span>a + <span class="kw-2">&amp;</span>b).print();
    (<span class="kw-2">&amp;</span>a - <span class="kw-2">&amp;</span>b).print();
    (<span class="kw-2">&amp;</span>a * <span class="kw-2">&amp;</span>b).print();
}</code></pre></div>
</li>
</ul>
<h3 id="extract--modify-components"><a class="doc-anchor" href="#extract--modify-components">§</a>Extract &amp; modify components</h3>
<ul>
<li>
<p>In peroxide, matrix data is saved as linear structure.</p>
</li>
<li>
<p>But you can use two-dimensional index to extract or modify components.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[macro_use]
</span><span class="kw">extern crate </span>peroxide;
<span class="kw">use </span>peroxide::fuga::<span class="kw-2">*</span>;

<span class="kw">fn </span>main() {
    <span class="kw">let </span><span class="kw-2">mut </span>a = <span class="macro">matrix!</span>(<span class="number">1</span>;<span class="number">4</span>;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, Row);
    a[(<span class="number">0</span>,<span class="number">0</span>)].print();   <span class="comment">// 1
    </span>a[(<span class="number">0</span>,<span class="number">0</span>)] = <span class="number">2f64</span>;    <span class="comment">// Modify component
    </span>a.print();
    <span class="comment">//       c[0] c[1]
    //  r[0]    2    2
    //  r[1]    3    4
</span>}</code></pre></div>
</li>
</ul>
<h3 id="conversion-to-vecf64"><a class="doc-anchor" href="#conversion-to-vecf64">§</a>Conversion to <code>Vec&lt;f64&gt;</code></h3>
<ul>
<li>
<p>Just use <code>row</code> or <code>col</code> method (I already showed at Basic method section).</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[macro_use]
</span><span class="kw">extern crate </span>peroxide;
<span class="kw">use </span>peroxide::fuga::<span class="kw-2">*</span>;

<span class="kw">fn </span>main() {
    <span class="kw">let </span>a = <span class="macro">matrix!</span>(<span class="number">1</span>;<span class="number">4</span>;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, Row);
    a.row(<span class="number">0</span>).print(); <span class="comment">// [1, 2]
    </span><span class="macro">assert_eq!</span>(a.row(<span class="number">0</span>), <span class="macro">vec!</span>[<span class="number">1f64</span>, <span class="number">2f64</span>]);
}</code></pre></div>
</li>
</ul>
<h3 id="useful-constructor"><a class="doc-anchor" href="#useful-constructor">§</a>Useful constructor</h3>
<ul>
<li>
<p><code>zeros(usize, usize)</code>: Construct matrix which elements are all zero</p>
</li>
<li>
<p><code>eye(usize)</code>: Identity matrix</p>
</li>
<li>
<p><code>rand(usize, usize)</code>: Construct random uniform matrix (from 0 to 1)</p>
</li>
<li>
<p><code>rand_with_rng(usize, usize, &amp;mut Rng)</code>: Construct random matrix with user-defined RNG</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>peroxide::fuga::<span class="kw-2">*</span>;

<span class="kw">fn </span>main() {
    <span class="kw">let </span>a = zeros(<span class="number">2</span>, <span class="number">2</span>);
    <span class="macro">assert_eq!</span>(a, ml_matrix(<span class="string">"0 0;0 0"</span>));

    <span class="kw">let </span>b = eye(<span class="number">2</span>);
    <span class="macro">assert_eq!</span>(b, ml_matrix(<span class="string">"1 0;0 1"</span>));

    <span class="kw">let </span>c = rand(<span class="number">2</span>, <span class="number">2</span>);
    c.print(); <span class="comment">// Random 2x2 matrix
</span>}</code></pre></div>
</li>
</ul>
<h2 id="linear-algebra"><a class="doc-anchor" href="#linear-algebra">§</a>Linear Algebra</h2><h3 id="transpose"><a class="doc-anchor" href="#transpose">§</a>Transpose</h3>
<ul>
<li>
<p>Caution: Transpose does not consume the original value.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[macro_use]
</span><span class="kw">extern crate </span>peroxide;
<span class="kw">use </span>peroxide::fuga::<span class="kw-2">*</span>;

<span class="kw">fn </span>main() {
    <span class="kw">let </span>a = <span class="macro">matrix!</span>(<span class="number">1</span>;<span class="number">4</span>;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, Row);
    a.transpose().print();
    <span class="comment">// Or you can use shorter one
    </span>a.t().print();
    <span class="comment">//      c[0] c[1]
    // r[0]    1    3
    // r[1]    2    4
</span>}</code></pre></div>
</li>
</ul>
<h3 id="lu-decomposition"><a class="doc-anchor" href="#lu-decomposition">§</a>LU Decomposition</h3>
<ul>
<li>
<p>Peroxide uses <strong>complete pivoting</strong> for LU decomposition - Very stable</p>
</li>
<li>
<p>Since there are lots of causes to generate error, you should use <code>Option</code></p>
</li>
<li>
<p><code>lu</code> returns <code>PQLU</code></p>
<ul>
<li><code>PQLU</code> has four field - <code>p</code>, <code>q</code>, <code>l</code> , <code>u</code></li>
<li><code>p</code> means row permutations</li>
<li><code>q</code> means column permutations</li>
<li><code>l</code> means lower triangular matrix</li>
<li><code>u</code> menas upper triangular matrix</li>
</ul>
</li>
<li>
<p>The structure of <code>PQLU</code> is as follows:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>peroxide::fuga::<span class="kw-2">*</span>;

<span class="attr">#[derive(Debug, Clone)]
</span><span class="kw">pub struct </span>PQLU {
    <span class="kw">pub </span>p: Vec&lt;usize&gt;,
    <span class="kw">pub </span>q: Vec&lt;usize&gt;,
    <span class="kw">pub </span>l: Matrix,
    <span class="kw">pub </span>u: Matrix,
}</code></pre></div>
</li>
<li>
<p>Example of LU decomposition:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[macro_use]
</span><span class="kw">extern crate </span>peroxide;
<span class="kw">use </span>peroxide::fuga::<span class="kw-2">*</span>;

<span class="kw">fn </span>main() {
    <span class="kw">let </span>a = matrix(<span class="macro">c!</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>), <span class="number">2</span>, <span class="number">2</span>, Row);
    <span class="kw">let </span>pqlu = a.lu();
    <span class="kw">let </span>(p,q,l,u) = (pqlu.p, pqlu.q, pqlu.l, pqlu.u);
    <span class="macro">assert_eq!</span>(p, <span class="macro">vec!</span>[<span class="number">1</span>]); <span class="comment">// swap 0 &amp; 1 (Row)
    </span><span class="macro">assert_eq!</span>(q, <span class="macro">vec!</span>[<span class="number">1</span>]); <span class="comment">// swap 0 &amp; 1 (Col)
    </span><span class="macro">assert_eq!</span>(l, matrix(<span class="macro">c!</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">0.5</span>,<span class="number">1</span>),<span class="number">2</span>,<span class="number">2</span>,Row));
    <span class="comment">//      c[0] c[1]
    // r[0]    1    0
    // r[1]  0.5    1
    </span><span class="macro">assert_eq!</span>(u, matrix(<span class="macro">c!</span>(<span class="number">4</span>,<span class="number">3</span>,<span class="number">0</span>,-<span class="number">0.5</span>),<span class="number">2</span>,<span class="number">2</span>,Row));
    <span class="comment">//      c[0] c[1]
    // r[0]    4    3
    // r[1]    0 -0.5
</span>}</code></pre></div>
</li>
</ul>
<h3 id="determinant"><a class="doc-anchor" href="#determinant">§</a>Determinant</h3>
<ul>
<li>
<p>Peroxide uses LU decomposition to obtain determinant ($ \mathcal{O}(n^3) $)</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[macro_use]
</span><span class="kw">extern crate </span>peroxide;
<span class="kw">use </span>peroxide::fuga::<span class="kw-2">*</span>;

<span class="kw">fn </span>main() {
    <span class="kw">let </span>a = <span class="macro">matrix!</span>(<span class="number">1</span>;<span class="number">4</span>;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, Row);
    <span class="macro">assert_eq!</span>(a.det(), -<span class="number">2f64</span>);
}</code></pre></div>
</li>
</ul>
<h3 id="inverse-matrix"><a class="doc-anchor" href="#inverse-matrix">§</a>Inverse matrix</h3>
<ul>
<li>Peroxide uses LU decomposition (via GECP) to obtain inverse matrix.</li>
<li>It needs two sub functions - <code>inv_l</code>, <code>inv_u</code>
<ul>
<li>For inverse of <code>L, U</code>, I use block partitioning. For example, for lower triangular matrix :
$$ \begin{aligned} L &amp;= \begin{pmatrix} L_1 &amp; \mathbf{0} \\ L_2 &amp; L_3 \end{pmatrix} \\ L^{-1} &amp;= \begin{pmatrix} L_1^{-1} &amp; \mathbf{0} \\ -L_3^{-1}L_2 L_1^{-1} &amp; L_3^{-1} \end{pmatrix} \end{aligned} $$</li>
</ul>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[macro_use]
</span><span class="kw">extern crate </span>peroxide;
<span class="kw">use </span>peroxide::fuga::<span class="kw-2">*</span>;

<span class="kw">fn </span>main() {
    <span class="kw">let </span>a = <span class="macro">matrix!</span>(<span class="number">1</span>;<span class="number">4</span>;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, Row);
    a.inv().print();
    <span class="comment">//      c[0] c[1]
    // r[0]   -2    1
    // r[1]  1.5 -0.5
</span>}</code></pre></div>
</li>
</ul>
<h3 id="tips-for-lu-det-inverse"><a class="doc-anchor" href="#tips-for-lu-det-inverse">§</a>Tips for LU, Det, Inverse</h3>
<ul>
<li>If you save <code>self.lu()</code> rather than the direct use of <code>self.det()</code> or <code>self.lu()</code> then you can get better performance (via memoization)</li>
</ul>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>peroxide::fuga::<span class="kw-2">*</span>;

<span class="kw">fn </span>main() {
    <span class="kw">let </span>a = ml_matrix(<span class="string">"1 2;3 4"</span>);
    <span class="kw">let </span>pqlu = a.lu();  <span class="comment">// Memoization of LU
    </span>pqlu.det().print(); <span class="comment">// Same as a.det() but do not need an additional LU
    </span>pqlu.inv().print(); <span class="comment">// Same as a.inv() but do not need an additional LU
</span>}</code></pre></div>
<h3 id="qr-decomposition-o3-feature-only"><a class="doc-anchor" href="#qr-decomposition-o3-feature-only">§</a>QR Decomposition (<code>O3</code> feature only)</h3>
<ul>
<li>
<p>Use <code>dgeqrf</code> of LAPACK</p>
</li>
<li>
<p>Return <code>QR</code> structure.</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">pub struct </span>QR {
    <span class="kw">pub </span>q: Matrix,
    <span class="kw">pub </span>r: Matrix,
}</code></pre></div>
</li>
<li>
<p>Example</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">use </span>peroxide::fuga::<span class="kw-2">*</span>;

<span class="kw">let </span>a = ml_matrix(<span class="string">"
    1 -1 4;
    1 4 -2;
    1 4 2;
    1 -1 0
"</span>);

<span class="comment">// QR decomposition
</span><span class="kw">let </span>qr = a.qr();

qr.q().print();
<span class="comment">//         c[0]    c[1]    c[2]
// r[0]    -0.5     0.5    -0.5
// r[1]    -0.5 -0.5000  0.5000
// r[2]    -0.5 -0.5000    -0.5
// r[3]    -0.5     0.5  0.5000

</span>qr.r().print();
<span class="comment">//      c[0] c[1] c[2]
// r[0]   -2   -3   -2
// r[1]    0   -5    2
// r[2]    0    0   -4</span></code></pre></div>
</li>
</ul>
<h3 id="singular-value-decomposition-o3-feature-only"><a class="doc-anchor" href="#singular-value-decomposition-o3-feature-only">§</a>Singular Value Decomposition (<code>O3</code> feature only)</h3>
<ul>
<li>
<p>Use <code>dgesvd</code> of LAPACK</p>
</li>
<li>
<p>Return <code>SVD</code> structure</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>peroxide::fuga::<span class="kw-2">*</span>;

<span class="kw">pub struct </span>SVD {
    <span class="kw">pub </span>s: Vec&lt;f64&gt;,
    <span class="kw">pub </span>u: Matrix,
    <span class="kw">pub </span>vt: Matrix,
}</code></pre></div>
</li>
<li>
<p>Example</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>peroxide::fuga::<span class="kw-2">*</span>;

<span class="kw">fn </span>main() {
    <span class="kw">let </span>a = ml_matrix(<span class="string">"3 2 2;2 3 -2"</span>);
    <span class="attr">#[cfg(feature=<span class="string">"O3"</span>)]
    </span>{
        <span class="comment">// Full SVD
        </span><span class="kw">let </span>svd = a.svd();
        <span class="macro">assert!</span>(eq_vec(<span class="kw-2">&amp;</span><span class="macro">vec!</span>[<span class="number">5f64</span>, <span class="number">3f64</span>], <span class="kw-2">&amp;</span>svd.s, <span class="number">1e-7</span>));

        <span class="comment">// Or Truncated SVD
        </span><span class="kw">let </span>svd2 = svd.truncated();
        <span class="macro">assert!</span>(eq_vec(<span class="kw-2">&amp;</span><span class="macro">vec!</span>[<span class="number">5f64</span>, <span class="number">3f64</span>], <span class="kw-2">&amp;</span>svd2.s, <span class="number">1e-7</span>));
    }
    a.print();
}</code></pre></div>
</li>
</ul>
<h3 id="cholesky-decomposition"><a class="doc-anchor" href="#cholesky-decomposition">§</a>Cholesky Decomposition</h3>
<ul>
<li>
<p>Use <code>dpotrf</code> of LAPACK</p>
</li>
<li>
<p>Return Matrix (But there can be panic! - Not symmetric or Not positive definite)</p>
</li>
<li>
<p>Example</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">extern crate </span>peroxide;
<span class="kw">use </span>peroxide::fuga::<span class="kw-2">*</span>;

<span class="kw">fn </span>main() {
    <span class="kw">let </span>a = ml_matrix(<span class="string">"1 2;2 5"</span>);
    <span class="attr">#[cfg(feature = <span class="string">"O3"</span>)]
    </span>{
        <span class="kw">let </span>u = a.cholesky(Upper);
        <span class="macro">assert_eq!</span>(u, ml_matrix(<span class="string">"1 2;0 1"</span>));

        <span class="kw">let </span>l = a.cholesky(Lower);
        <span class="macro">assert_eq!</span>(l, ml_matrix(<span class="string">"1 0;2 1"</span>));
    }
    a.print();
}</code></pre></div>
</li>
</ul>
<h3 id="moore-penrose-pseudo-inverse"><a class="doc-anchor" href="#moore-penrose-pseudo-inverse">§</a>Moore-Penrose Pseudo Inverse</h3>
<ul>
<li>
<p>$ X^\dagger = \left(X^T X\right)^{-1} X^T $</p>
</li>
<li>
<p>For <code>O3</code> feature, peroxide use SVD to obtain pseudo inverse</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[macro_use]
</span><span class="kw">extern crate </span>peroxide;
<span class="kw">use </span>peroxide::fuga::<span class="kw-2">*</span>;

<span class="kw">fn </span>main() {
    <span class="kw">let </span>a = <span class="macro">matrix!</span>(<span class="number">1</span>;<span class="number">4</span>;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, Row);
    <span class="kw">let </span>pinv_a = a.pseudo_inv();
    <span class="kw">let </span>inv_a = a.inv();

    <span class="macro">assert_eq!</span>(inv_a, pinv_a); <span class="comment">// Nearly equal (not actually equal)
</span>}</code></pre></div>
</li>
</ul>
</div></details><h2 id="reexports" class="section-header">Re-exports<a href="#reexports" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name" id="reexport.Col"><code>pub use self::Shape::<a class="enum" href="enum.Shape.html" title="enum peroxide::structure::matrix::Shape">Col</a>;</code></div></li><li><div class="item-name" id="reexport.Row"><code>pub use self::Shape::<a class="enum" href="enum.Shape.html" title="enum peroxide::structure::matrix::Shape">Row</a>;</code></div></li></ul><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.DGEQRF.html" title="struct peroxide::structure::matrix::DGEQRF">DGEQRF</a></div><div class="desc docblock-short">Temporary data structure from <code>dgeqrf</code></div></li><li><div class="item-name"><a class="struct" href="struct.DGESVD.html" title="struct peroxide::structure::matrix::DGESVD">DGESVD</a></div></li><li><div class="item-name"><a class="struct" href="struct.DGETRF.html" title="struct peroxide::structure::matrix::DGETRF">DGETRF</a></div><div class="desc docblock-short">Temporary data structure from <code>dgetrf</code></div></li><li><div class="item-name"><a class="struct" href="struct.DPOTRF.html" title="struct peroxide::structure::matrix::DPOTRF">DPOTRF</a></div></li><li><div class="item-name"><a class="struct" href="struct.Matrix.html" title="struct peroxide::structure::matrix::Matrix">Matrix</a></div><div class="desc docblock-short">R-like matrix structure</div></li></ul><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.LAPACK_STATUS.html" title="enum peroxide::structure::matrix::LAPACK_STATUS">LAPACK_<wbr>STATUS</a></div></li><li><div class="item-name"><a class="enum" href="enum.POSITIVE_STATUS.html" title="enum peroxide::structure::matrix::POSITIVE_STATUS">POSITIVE_<wbr>STATUS</a></div></li><li><div class="item-name"><a class="enum" href="enum.SVD_STATUS.html" title="enum peroxide::structure::matrix::SVD_STATUS">SVD_<wbr>STATUS</a></div></li><li><div class="item-name"><a class="enum" href="enum.Shape.html" title="enum peroxide::structure::matrix::Shape">Shape</a></div><div class="desc docblock-short">To select matrices’ binding.</div></li></ul><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.Error.html" title="trait peroxide::structure::matrix::Error">Error</a></div><div class="desc docblock-short"><code>Error</code> is a trait representing the basic expectations for error values,
i.e., values of type <code>E</code> in <a href="https://doc.rust-lang.org/1.85.1/core/result/enum.Result.html" title="enum core::result::Result"><code>Result&lt;T, E&gt;</code></a>.</div></li></ul><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.blas_mul.html" title="fn peroxide::structure::matrix::blas_mul">blas_<wbr>mul</a></div><div class="desc docblock-short">Matrix multiplication with BLAS</div></li><li><div class="item-name"><a class="fn" href="fn.combine.html" title="fn peroxide::structure::matrix::combine">combine</a></div><div class="desc docblock-short">Combine separated matrix to one matrix</div></li><li><div class="item-name"><a class="fn" href="fn.diag.html" title="fn peroxide::structure::matrix::diag">diag</a></div></li><li><div class="item-name"><a class="fn" href="fn.gemm.html" title="fn peroxide::structure::matrix::gemm">gemm</a></div><div class="desc docblock-short">GEMM wrapper for Matrixmultiply</div></li><li><div class="item-name"><a class="fn" href="fn.gemv.html" title="fn peroxide::structure::matrix::gemv">gemv</a></div><div class="desc docblock-short">General Matrix-Vector multiplication</div></li><li><div class="item-name"><a class="fn" href="fn.gen_householder.html" title="fn peroxide::structure::matrix::gen_householder">gen_<wbr>householder</a></div></li><li><div class="item-name"><a class="fn" href="fn.gevm.html" title="fn peroxide::structure::matrix::gevm">gevm</a></div><div class="desc docblock-short">General Vector-Matrix multiplication</div></li><li><div class="item-name"><a class="fn" href="fn.inv_l.html" title="fn peroxide::structure::matrix::inv_l">inv_l</a></div><div class="desc docblock-short">Inverse of Lower matrix</div></li><li><div class="item-name"><a class="fn" href="fn.inv_u.html" title="fn peroxide::structure::matrix::inv_u">inv_u</a></div><div class="desc docblock-short">Inverse of upper triangular matrix</div></li><li><div class="item-name"><a class="fn" href="fn.lapack_dgeqrf.html" title="fn peroxide::structure::matrix::lapack_dgeqrf">lapack_<wbr>dgeqrf</a></div><div class="desc docblock-short">Peroxide version of <code>dgeqrf</code></div></li><li><div class="item-name"><a class="fn" href="fn.lapack_dgesvd.html" title="fn peroxide::structure::matrix::lapack_dgesvd">lapack_<wbr>dgesvd</a></div></li><li><div class="item-name"><a class="fn" href="fn.lapack_dgetrf.html" title="fn peroxide::structure::matrix::lapack_dgetrf">lapack_<wbr>dgetrf</a></div><div class="desc docblock-short">Peroxide version of <code>dgetrf</code></div></li><li><div class="item-name"><a class="fn" href="fn.lapack_dgetri.html" title="fn peroxide::structure::matrix::lapack_dgetri">lapack_<wbr>dgetri</a></div><div class="desc docblock-short">Peroxide version of <code>dgetri</code></div></li><li><div class="item-name"><a class="fn" href="fn.lapack_dgetrs.html" title="fn peroxide::structure::matrix::lapack_dgetrs">lapack_<wbr>dgetrs</a></div><div class="desc docblock-short">Peroxide version of <code>dgetrs</code></div></li><li><div class="item-name"><a class="fn" href="fn.lapack_dpotrf.html" title="fn peroxide::structure::matrix::lapack_dpotrf">lapack_<wbr>dpotrf</a></div></li><li><div class="item-name"><a class="fn" href="fn.matrix.html" title="fn peroxide::structure::matrix::matrix">matrix</a></div><div class="desc docblock-short">R-like matrix constructor</div></li><li><div class="item-name"><a class="fn" href="fn.ml_matrix.html" title="fn peroxide::structure::matrix::ml_matrix">ml_<wbr>matrix</a></div><div class="desc docblock-short">Matlab-like matrix constructor</div></li><li><div class="item-name"><a class="fn" href="fn.py_matrix.html" title="fn peroxide::structure::matrix::py_matrix">py_<wbr>matrix</a></div><div class="desc docblock-short">Python-like matrix constructor</div></li><li><div class="item-name"><a class="fn" href="fn.r_matrix.html" title="fn peroxide::structure::matrix::r_matrix">r_<wbr>matrix</a></div><div class="desc docblock-short">R-like matrix constructor (Explicit ver.)</div></li></ul><h2 id="types" class="section-header">Type Aliases<a href="#types" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="type" href="type.Perms.html" title="type peroxide::structure::matrix::Perms">Perms</a></div></li></ul></section></div></main></body></html>